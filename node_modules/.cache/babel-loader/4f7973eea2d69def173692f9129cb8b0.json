{"ast":null,"code":"import _createForOfIteratorHelper from\"/home/aditya2020/my-app/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createForOfIteratorHelper\";export function dijkstra(grid,startNode,finishNode){var visitedNodesInOrder=[];startNode.distance=0;var unvisitedNodes=getAllNodes(grid);while(!!unvisitedNodes.length){sortNodesByDistance(unvisitedNodes);var closestNode=unvisitedNodes.shift();if(closestNode.isBarrier)continue;if(closestNode.distance===Infinity)return visitedNodesInOrder;closestNode.isVisited=true;visitedNodesInOrder.push(closestNode);if(closestNode===finishNode)return visitedNodesInOrder;updateUnvisitedNeighbors(closestNode,grid);}}function sortNodesByDistance(unvisitedNodes){unvisitedNodes.sort(function(node1,node2){return node1.distance-node2.distance;});}function updateUnvisitedNeighbors(node,grid){var unvisitedNeighbors=getUnvisitedNeighbors(node,grid);var _iterator=_createForOfIteratorHelper(unvisitedNeighbors),_step;try{for(_iterator.s();!(_step=_iterator.n()).done;){var neighbor=_step.value;neighbor.distance=node.distance+1;neighbor.previousNode=node;}}catch(err){_iterator.e(err);}finally{_iterator.f();}}function getUnvisitedNeighbors(node,grid){var neighbors=[];var col=node.col,row=node.row;if(row>0)neighbors.push(grid[row-1][col]);if(row<grid.length-1)neighbors.push(grid[row+1][col]);if(col>0)neighbors.push(grid[row][col-1]);if(col<grid[0].length-1)neighbors.push(grid[row][col+1]);return neighbors.filter(function(neighbor){return!neighbor.isVisited;});}function getAllNodes(grid){var allNodes=[];var _iterator2=_createForOfIteratorHelper(grid),_step2;try{for(_iterator2.s();!(_step2=_iterator2.n()).done;){var row=_step2.value;var _iterator3=_createForOfIteratorHelper(row),_step3;try{for(_iterator3.s();!(_step3=_iterator3.n()).done;){var node=_step3.value;allNodes.push(node);}}catch(err){_iterator3.e(err);}finally{_iterator3.f();}}}catch(err){_iterator2.e(err);}finally{_iterator2.f();}return allNodes;}export function getNodesInShortestPath(finishNode){var nodesInShortestPath=[];var currNode=finishNode;while(currNode!==null){nodesInShortestPath.unshift(currNode);currNode=currNode.previousNode;}return nodesInShortestPath;}","map":{"version":3,"sources":["/home/aditya2020/my-app/src/algorithms/dijkstra.js"],"names":["dijkstra","grid","startNode","finishNode","visitedNodesInOrder","distance","unvisitedNodes","getAllNodes","length","sortNodesByDistance","closestNode","shift","isBarrier","Infinity","isVisited","push","updateUnvisitedNeighbors","sort","node1","node2","node","unvisitedNeighbors","getUnvisitedNeighbors","neighbor","previousNode","neighbors","col","row","filter","allNodes","getNodesInShortestPath","nodesInShortestPath","currNode","unshift"],"mappings":"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","sourcesContent":["export function dijkstra(grid, startNode, finishNode) \n{\n\tconst visitedNodesInOrder = [];\n\tstartNode.distance = 0;\n\tconst unvisitedNodes = getAllNodes(grid);\n\twhile (!!unvisitedNodes.length) \n\t{\n\t\tsortNodesByDistance(unvisitedNodes);\n\t\tconst closestNode = unvisitedNodes.shift();\n\t\tif (closestNode.isBarrier) continue;\n\t\tif (closestNode.distance === Infinity) return visitedNodesInOrder;\n\t\tclosestNode.isVisited = true;\n\t\tvisitedNodesInOrder.push(closestNode);\n\t\tif (closestNode === finishNode) return visitedNodesInOrder;\n\t\tupdateUnvisitedNeighbors(closestNode, grid);\n\t}\n}\n\nfunction sortNodesByDistance(unvisitedNodes) \n{\n\tunvisitedNodes.sort((node1, node2) => node1.distance - node2.distance);\n}\n\nfunction updateUnvisitedNeighbors(node, grid) \n{\n\tconst unvisitedNeighbors = getUnvisitedNeighbors(node, grid);\n\tfor (const neighbor of unvisitedNeighbors) \n\t{\n\t\tneighbor.distance = node.distance + 1;\n\t\tneighbor.previousNode = node;\n\t}\n}\n\nfunction getUnvisitedNeighbors(node, grid) \n{\n\tconst neighbors = [];\n\tconst {col, row} = node;\n\tif (row > 0) neighbors.push(grid[row - 1][col]);\n\tif (row < grid.length - 1) neighbors.push(grid[row + 1][col]);\n\tif (col > 0) neighbors.push(grid[row][col - 1]);\n\tif (col < grid[0].length - 1) neighbors.push(grid[row][col + 1]);\n\treturn neighbors.filter(neighbor => !neighbor.isVisited);\n}\n\nfunction getAllNodes(grid) \n{\n\tconst allNodes = [];\n\tfor (const row of grid) \n\t{\n\t\tfor (const node of row) \n\t\t{\n\t\t\tallNodes.push(node);\n\t\t}\n\t}\n\n\treturn allNodes;\n}\n\nexport function getNodesInShortestPath(finishNode) \n{\n\tconst nodesInShortestPath = [];\n\tlet currNode = finishNode;\n\twhile (currNode !== null)\n\t{\n\t\tnodesInShortestPath.unshift(currNode);\n\t\tcurrNode = currNode.previousNode;\n\t}\n\n\treturn nodesInShortestPath;\n}"]},"metadata":{},"sourceType":"module"}